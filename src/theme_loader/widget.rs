// Copyright 2021 the Druid Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

use std::path::PathBuf;

#[cfg(feature = "notify")]
use druid::ExtEventSink;
use druid::{widget::prelude::*, Selector};

use crate::theme_loader::{LoadableTheme, ThemeLoadError};

pub const RELOAD_THEME: Selector<()> = Selector::new("runebender.theme-loader-reload");

/// A widget that loads a theme from file and applies it to the [`Env`].
///
/// This can optionally reload the theme when it changes, if the `notify`
/// feature is enabled.
pub struct ThemeLoader<T, W> {
    theme_path: PathBuf,
    theme: T,
    current_env: Option<Env>,
    inner: W,
}

impl<T: LoadableTheme, W> ThemeLoader<T, W> {
    /// Create a new `ThemeLoader`.
    ///
    /// The `path` argument should be a path to the theme file. The `them`
    /// argument is a theme generated by the [`loadable_theme!`] macro.
    ///
    /// [`loadable_theme!`] crate::loadable_theme
    pub fn new(path: impl Into<PathBuf>, theme: T, inner: W) -> Self {
        ThemeLoader {
            theme_path: path.into(),
            theme,
            inner,
            current_env: None,
        }
    }

    fn add_env_to_theme(&mut self, env: &Env) -> Result<Env, ThemeLoadError> {
        let file_contents = std::fs::read_to_string(&self.theme_path)?;
        let contents = iter_items(&file_contents).collect::<Result<_, _>>()?;
        self.theme.load(&contents, env)
    }

    fn reload_theme_and_log_errors(&mut self, env: &Env) {
        match self.add_env_to_theme(env) {
            Ok(new_env) => self.current_env = Some(new_env),
            Err(e) => log::error!("error loading theme file: {}", e),
        }
    }
}

fn iter_items(s: &str) -> impl Iterator<Item = Result<(&str, &str), ThemeLoadError>> {
    s.lines().filter_map(|line| {
        if line.trim().is_empty() {
            None
        } else {
            let mut split = line.split(':');
            match (split.next(), split.next(), split.next()) {
                (Some(key), Some(val), None) => Some(Ok((key.trim(), val.trim()))),
                _ => Some(Err(ThemeLoadError::ParseThemeLineError(line.to_string()))),
            }
        }
    })
}

impl<T, S, W> Widget<T> for ThemeLoader<S, W>
where
    T: Data,
    S: LoadableTheme,
    W: Widget<T>,
{
    fn event(&mut self, ctx: &mut EventCtx, event: &Event, data: &mut T, env: &Env) {
        match event {
            Event::WindowConnected => {
                #[cfg(feature = "notify")]
                {
                    let event_snk = ctx.get_external_handle();
                    start_watcher(event_snk, self.theme_path.clone(), ctx.widget_id());
                }
                self.reload_theme_and_log_errors(env);
                // spin up our watcher thread
            }
            // FIXME: this is when we receive the command back from the watcher thread
            Event::Command(cmd) if cmd.is(RELOAD_THEME) => {
                log::info!("reloading theme");
                self.reload_theme_and_log_errors(env);
                ctx.request_layout();
                ctx.set_handled();
            }
            _ => (),
        }
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.event(ctx, event, data, child_env);
    }

    fn lifecycle(&mut self, ctx: &mut LifeCycleCtx, event: &LifeCycle, data: &T, env: &Env) {
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.lifecycle(ctx, event, data, child_env)
    }

    fn update(&mut self, ctx: &mut UpdateCtx, old_data: &T, data: &T, env: &Env) {
        if ctx.env_changed() {
            self.reload_theme_and_log_errors(env);
        }

        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.update(ctx, old_data, data, child_env);
    }

    fn layout(&mut self, ctx: &mut LayoutCtx, bc: &BoxConstraints, data: &T, env: &Env) -> Size {
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.layout(ctx, bc, data, child_env)
    }

    fn paint(&mut self, ctx: &mut PaintCtx, data: &T, env: &Env) {
        let child_env = self.current_env.as_ref().unwrap_or(env);
        self.inner.paint(ctx, data, child_env);
    }
}

#[cfg(feature = "notify")]
fn start_watcher(sink: ExtEventSink, path: PathBuf, target: WidgetId) {
    use notify::{DebouncedEvent, RecursiveMode, Watcher};
    use std::sync::mpsc;
    use std::time::Duration;
    std::thread::spawn(move || {
        let (tx, rx) = mpsc::channel();
        let mut watcher = notify::watcher(tx, Duration::from_millis(500)).unwrap();
        if let Err(e) = watcher.watch(&path, RecursiveMode::NonRecursive) {
            log::error!(
                "theme watcher failed to watch path '{}': '{}'",
                path.to_string_lossy(),
                e
            );
            return;
        }

        loop {
            match rx.recv() {
                Ok(DebouncedEvent::Write(_)) => {
                    log::info!("sending reload command");
                    if sink.submit_command(RELOAD_THEME, (), target).is_err() {
                        break;
                    }
                }
                Ok(other) => log::debug!("other event {:?}", other),
                Err(e) => {
                    log::error!("watch error: {:?}", e);
                    break;
                }
            }
        }
    });
}
